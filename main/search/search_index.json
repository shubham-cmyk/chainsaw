{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"docs/","title":"Documentation","text":"<p>Starting with Chainsaw <code>v0.0.6</code> we maintain docs per version:</p> <ul> <li>Every version released has its own documentation</li> <li>Current work in progress (<code>main</code> branch) is available too</li> </ul>"},{"location":"gh-action/","title":"GitHub action","text":"<p>A GitHub action is available to easily install Chainsaw in your workflows.</p> <p>The GitHub action is available at kyverno/chainsaw/.github/actions/install.</p>"},{"location":"gh-action/#usage","title":"Usage","text":"<p>This action currently supports GitHub-provided Linux, macOS and Windows runners (self-hosted runners may not work).</p> <p>Add the following entry to your Github workflow YAML file:</p> <pre><code>uses: kyverno/chainsaw/.github/actions/install@&lt;version&gt;\nwith:\n  release: 'v0.0.3' # optional\n</code></pre> <p>Example using a pinned version:</p> <pre><code>jobs:\n  example:\n    runs-on: ubuntu-latest\n\n    permissions: {}\n\n    name: Install Chainsaw\n    steps:\n      - name: Install Chainsaw\n        uses: kyverno/chainsaw/.github/actions/install@&lt;version&gt;\n        with:\n          release: 'v1.9.5'\n      - name: Check install\n        run: chainsaw version\n</code></pre> <p>Example using the default version:</p> <pre><code>jobs:\n  example:\n    runs-on: ubuntu-latest\n\n    permissions: {}\n\n    name: Install Chainsaw\n    steps:\n      - name: Install Chainsaw\n        uses: kyverno/chainsaw/.github/actions/install@&lt;version&gt;\n      - name: Check install\n        run: chainsaw version\n</code></pre> <p>Example using cosign verification:</p> <pre><code>jobs:\n  example:\n    runs-on: ubuntu-latest\n\n    permissions: {}\n\n    name: Install Chainsaw\n    steps:\n      - name: Install Cosign\n        uses: sigstore/cosign-installer@v3.1.1\n      - name: Install Chainsaw\n        uses: kyverno/chainsaw/.github/actions/install@&lt;version&gt;\n        with:\n          verify: true\n      - name: Check install\n        run: chainsaw version\n</code></pre> <p>If you want to install Chainsaw from its main version by using <code>go install</code> under the hood, you can set <code>release</code> as <code>main</code>. Once you did that, Chainsaw will be installed via <code>go install</code> which means that please ensure that go is installed.</p> <p>Example of installing Chainsaw via <code>go install</code>:</p> <pre><code>jobs:\n  example:\n    runs-on: ubuntu-latest\n\n    permissions: {}\n\n    name: Install Chainsaw via go install\n    steps:\n      - name: Install go\n        uses: actions/setup-go@v4\n        with:\n          go-version: '1.20'\n          check-latest: true\n      - name: Install Chainsaw\n        uses: kyverno/chainsaw/.github/actions/install@&lt;version&gt;\n        with:\n          release: main\n      - name: Check install\n        run: chainsaw version\n</code></pre>"},{"location":"gh-action/#optional-inputs","title":"Optional Inputs","text":"<p>The following optional inputs:</p> Input Description <code>release</code> <code>chainsaw</code> version to use instead of the default. <code>install-dir</code> directory to place the <code>chainsaw</code> binary into instead of the default (<code>$HOME/.chainsaw</code>). <code>use-sudo</code> set to <code>true</code> if <code>install-dir</code> location requires sudo privs. Defaults to false. <code>verify</code> set to <code>true</code> to enable cosign verification of the downloaded archive."},{"location":"install/","title":"Install","text":"<p>You can install the pre-compiled binary (in several ways), or compile from source.</p>"},{"location":"install/#install-using-go-install","title":"Install using <code>go install</code>","text":"<p>You can install with <code>go install</code> with:</p> <pre><code>go install github.com/kyverno/chainsaw@latest\n</code></pre>"},{"location":"install/#manually","title":"Manually","text":"<p>Download the pre-compiled binaries from the releases page and copy them to the desired location.</p>"},{"location":"install/#install-using-docker","title":"Install using Docker","text":"<p>Chainsaw is also available as a Docker image which you can pull and run:</p> <pre><code>docker pull ghcr.io/kyverno/chainsaw:&lt;version&gt;\n</code></pre> <p>Info</p> <p>Since Chainsaw relies on files for its operation (like test definitions), you will need to bind mount the necessary directories when running it via Docker.</p> <pre><code>docker run --rm                         \\\n    -v /path/on/host:/path/in/container \\\n    ghcr.io/kyverno/chainsaw:&lt;version&gt;  \\\n    &lt;chainsaw-command&gt;\n</code></pre>"},{"location":"install/#compile-from-sources","title":"Compile from sources","text":"<p>clone:</p> <p><pre><code>git clone https://github.com/kyverno/chainsaw.git\n</code></pre> build the binaries:</p> <pre><code>cd chainsaw\ngo mod tidy\nmake build\n</code></pre> <p>verify it works:</p> <pre><code>./chainsaw version\n</code></pre>"},{"location":"intro/","title":"Introduction","text":"<p>Chainsaw is a tool developed to run end to end tests in Kubernetes clusters.</p> <p>How it works</p> <p>It is meant to test Kubernetes operators work as expected by running a sequence of test steps for:</p> <ul> <li>creating resources</li> <li>and asserting operators react (or not) in the expected way.</li> </ul>"},{"location":"intro/#why-we-made-it","title":"Why we made it ?","text":"<p>While developing Kyverno we needed to run end to end tests to make sure our admission controller worked as expected.</p> <p>A typical Kyverno end to end test</p> <p>Kyverno can validate, mutate and generate resources based on policies installed in a cluster and a typical test is:</p> <ol> <li>Create a policy</li> <li>Create a resource</li> <li>Check that Kyverno acted as expected</li> <li>Cleanup and move to the next test</li> </ol> <p>We started with another tool called KUTTL. While KUTTL is great we identified some limitations and forked the tool to add the features we needed.</p> <p>But we ended up needing more flexibility than what KUTTL could offer and we started designing a new assertion model.</p> <p>At this point it was simpler to start a new tool from scratch than continuing making changes in our KUTTL fork.</p> <p>KUTTL compatibility</p> <p>Migrating from KUTTL to Chainsaw should be easy, the assertion model used in KUTTL is compatible with Chainsaw. We provide a <code>chainsaw kuttl migrate</code> command to help with the migration, see Migration from KUTTL for details.</p>"},{"location":"intro/#use-cases","title":"Use cases","text":"<p>Chainsaw is built with CI tools in mind - you only really need to download and execute it in your build script.</p> <p>Installing it in your machine is entirely up to you, but still possible.</p>"},{"location":"quick-start/","title":"Quick start","text":"<p>To use Chainsaw you will need a Kubernetes cluster, Chainsaw won't create one for you.</p> <p>In this Quick start we will use kind but feel free to use the tool of your choice.</p> <p>Not a cluster management tool</p> <p>We consider this is not the responsibility of Chainsaw to manage clusters.</p> <p>There are plenty of solutions to create and manage local clusters that will do that better than Chainsaw.</p>"},{"location":"quick-start/#create-a-kind-cluster","title":"Create a kind cluster","text":"<p>Please refer to the kind install docs to install it locally.</p> <p>Once kind creating a local cluster is as simple as running:</p> <pre><code># define kind image\nexport KIND_IMAGE=\"kindest/node:v1.28.0\"\n\n# create cluster\nkind create cluster --image $KIND_IMAGE\n</code></pre>"},{"location":"quick-start/#writing-tests","title":"Writing tests","text":"<p>A Chainsaw test is made of YAML files in a folder.</p> <p>Every file contains a <code>TestStep</code> and Chainsaw will run every step sequentially.</p> <p>For this Quick start, we will create a two step test:</p> <ol> <li>Create a <code>ConfigMap</code> from a manifest</li> <li>Verify the <code>ConfigMap</code> was created and contains the expected data</li> </ol>"},{"location":"quick-start/#create-the-test-folder","title":"Create the test folder","text":"<pre><code># create test folder\nmkdir chainsaw-quick-start\n\n# enter test folder\ncd chainsaw-quick-start\n</code></pre>"},{"location":"quick-start/#create-a-configmap","title":"Create a <code>ConfigMap</code>","text":"<pre><code># create a ConfigMap\ncat &gt; configmap.yaml &lt;&lt; EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\nEOF\n</code></pre>"},{"location":"quick-start/#create-the-test","title":"Create the test","text":"<p>By default, Chainsaw looks for a file named chainsaw-test.yaml. If you don't specify a filename, Chainsaw will use this default. However, you can specify a different file using the --test-file argument.</p> <pre><code># create test file\ncat &gt; chainsaw-test.yaml &lt;&lt; EOF\napiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: quick-start\nspec:\n  steps:\n  # first step applies the config map\n  - try:\n    - apply:\n        # file is relative to the test folder\n        file: configmap.yaml\n  # second step verifies the config map exists and contains the expected data\n  - try:\n    - assert:\n        # file is relative to the test folder\n        file: configmap.yaml\nEOF\n</code></pre>"},{"location":"quick-start/#run-chainsaw","title":"Run Chainsaw","text":"<p>We finished writing our first test, now we can run Chainsaw to verify the test runs as expected:</p> <pre><code>chainsaw test --test-dir .\n\nLoading default configuration...\n- Using test file: chainsaw-test.yaml\n- TestDirs [.]\n- SkipDelete false\n- FailFast false\n- ReportFormat ''\n- ReportName 'chainsaw-report'\n- Namespace ''\n- FullName false\n- IncludeTestRegex ''\n- ExcludeTestRegex ''\nLoading tests...\n- quick-start (.)\nRunning tests...\n=== RUN   chainsaw\n=== RUN   chainsaw/quick-start\n=== PAUSE chainsaw/quick-start\n=== CONT  chainsaw/quick-start\n    09:45:36 | quick-start | @setup | CREATE    | OK    | v1/Namespace | chainsaw-eternal-elk\n    09:45:36 | quick-start | step-1 | TRY       | RUN   |\n    09:45:36 | quick-start | step-1 | APPLY     | RUN   | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-1 | CREATE    | OK    | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-1 | APPLY     | DONE  | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-1 | TRY       | DONE  |\n    09:45:36 | quick-start | step-2 | TRY       | RUN   |\n    09:45:36 | quick-start | step-2 | ASSERT    | RUN   | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-2 | ASSERT    | DONE  | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-2 | TRY       | DONE  |\n    09:45:36 | quick-start | step-1 | DELETE    | RUN   | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-1 | DELETE    | OK    | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | step-1 | DELETE    | DONE  | v1/ConfigMap | chainsaw-eternal-elk/chainsaw-quick-start\n    09:45:36 | quick-start | @setup | DELETE    | RUN   | v1/Namespace | chainsaw-eternal-elk\n    09:45:36 | quick-start | @setup | DELETE    | OK    | v1/Namespace | chainsaw-eternal-elk\n    09:45:41 | quick-start | @setup | DELETE    | DONE  | v1/Namespace | chainsaw-eternal-elk\n--- PASS: chainsaw (0.00s)\n    --- PASS: chainsaw/quick-start (5.43s)\nPASS\nTests Summary...\n- Passed  tests 1\n- Failed  tests 0\n- Skipped tests 0\nDone.\n</code></pre>"},{"location":"apis/chainsaw.v1alpha1/","title":"chainsaw (v1alpha1)","text":"<p>Package v1alpha1 contains API Schema definitions for the v1alpha1 API group.</p>"},{"location":"apis/chainsaw.v1alpha1/#resource-types","title":"Resource Types","text":"<ul> <li>Configuration</li> <li>Test</li> <li>TestStep</li> </ul>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Configuration","title":"<code>Configuration</code>","text":"<p>Configuration is the resource that contains the configuration used to run tests.</p> Field Type Required Inline Description <code>apiVersion</code> <code>string</code> <code>chainsaw.kyverno.io/v1alpha1</code> <code>kind</code> <code>string</code> <code>Configuration</code> <code>metadata</code> <code>meta/v1.ObjectMeta</code> <p>Standard object's metadata.</p> <code>spec</code> <code>ConfigurationSpec</code> <p>Configuration spec.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Test","title":"<code>Test</code>","text":"<p>Test is the resource that contains aa test definition.</p> Field Type Required Inline Description <code>apiVersion</code> <code>string</code> <code>chainsaw.kyverno.io/v1alpha1</code> <code>kind</code> <code>string</code> <code>Test</code> <code>metadata</code> <code>meta/v1.ObjectMeta</code> <p>Standard object's metadata.</p> <code>spec</code> <code>TestSpec</code> <p>Test spec.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-TestStep","title":"<code>TestStep</code>","text":"<p>TestStep is the resource that contains the testStep used to run tests.</p> Field Type Required Inline Description <code>apiVersion</code> <code>string</code> <code>chainsaw.kyverno.io/v1alpha1</code> <code>kind</code> <code>string</code> <code>TestStep</code> <code>metadata</code> <code>meta/v1.ObjectMeta</code> <p>Standard object's metadata.</p> <code>spec</code> <code>TestStepSpec</code> <p>TestStep spec.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Apply","title":"<code>Apply</code>","text":"<p>Appears in:</p> <ul> <li>Operation</li> </ul> <p>Apply represents a set of configurations or resources that should be applied during testing.</p> Field Type Required Inline Description <code>FileRefOrResource</code> <code>FileRefOrResource</code> <p>FileRefOrResource provides a reference to the file containing the resources to be applied.</p> <code>dryRun</code> <code>bool</code> <p>DryRun determines whether the file should be applied in dry run mode.</p> <code>check</code> <code>github.com/kyverno/kyverno-json/pkg/apis/v1alpha1.Any</code> <p>Check is an assertion tree to validate outcome.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Assert","title":"<code>Assert</code>","text":"<p>Appears in:</p> <ul> <li>Operation</li> </ul> <p>Assert represents a test condition that is expected to hold true during the testing process.</p> Field Type Required Inline Description <code>FileRef</code> <code>FileRef</code> <p>FileRef provides a reference to the file containing the assertion.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Catch","title":"<code>Catch</code>","text":"<p>Appears in:</p> <ul> <li>TestStepSpec</li> </ul> <p>Catch defines actions to be executed on failure.</p> Field Type Required Inline Description <code>timeout</code> <code>meta/v1.Duration</code> <p>Timeout for the operation. Overrides the global timeout set in the Configuration.</p> <code>podLogs</code> <code>PodLogs</code> <p>PodLogs determines the pod logs collector to execute.</p> <code>events</code> <code>Events</code> <p>Events determines the events collector to execute.</p> <code>command</code> <code>Command</code> <p>Command defines a command to run.</p> <code>script</code> <code>Script</code> <p>Script defines a script to run.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Command","title":"<code>Command</code>","text":"<p>Appears in:</p> <ul> <li>Catch</li> <li>Finally</li> <li>Operation</li> </ul> <p>Command describes a command to run as a part of a test step.</p> Field Type Required Inline Description <code>entrypoint</code> <code>string</code> <p>Entrypoint is the command entry point to run.</p> <code>args</code> <code>[]string</code> <p>Args is the command arguments.</p> <code>skipLogOutput</code> <code>bool</code> <p>SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.</p> <code>check</code> <code>github.com/kyverno/kyverno-json/pkg/apis/v1alpha1.Any</code> <p>Check is an assertion tree to validate outcome.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-ConfigurationSpec","title":"<code>ConfigurationSpec</code>","text":"<p>Appears in:</p> <ul> <li>Configuration</li> </ul> <p>ConfigurationSpec contains the configuration used to run tests.</p> Field Type Required Inline Description <code>timeouts</code> <code>Timeouts</code> <p>Global timeouts configuration. Applies to all tests/test steps if not overridden.</p> <code>testDirs</code> <code>[]string</code> <p>Directories containing test cases to run.</p> <code>skipDelete</code> <code>bool</code> <p>If set, do not delete the resources after running the tests (implies SkipClusterDelete).</p> <code>failFast</code> <code>bool</code> <p>FailFast determines whether the test should stop upon encountering the first failure.</p> <code>parallel</code> <code>int</code> <p>The maximum number of tests to run at once.</p> <code>reportFormat</code> <code>ReportFormatType</code> <p>ReportFormat determines test report format (JSON <code>reportName</code> <code>string</code> <p>ReportName defines the name of report to create. It defaults to \"chainsaw-report\".</p> <code>namespace</code> <code>string</code> <p>Namespace defines the namespace to use for tests. If not specified, every test will execute in a random ephemeral namespace unless the namespace is overridden in a the test spec.</p> <code>fullName</code> <code>bool</code> <p>FullName makes use of the full test case folder path instead of the folder name.</p> <code>excludeTestRegex</code> <code>string</code> <p>ExcludeTestRegex is used to exclude tests based on a regular expression.</p> <code>includeTestRegex</code> <code>string</code> <p>IncludeTestRegex is used to include tests based on a regular expression.</p> <code>repeatCount</code> <code>int</code> <p>RepeatCount indicates how many times the tests should be executed.</p> <code>testFile</code> <code>string</code> <p>TestFile is the name of the file containing the test to run.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Create","title":"<code>Create</code>","text":"<p>Appears in:</p> <ul> <li>Operation</li> </ul> <p>Create represents a set of resources that should be created. If a resource already exists in the cluster it will fail.</p> Field Type Required Inline Description <code>FileRefOrResource</code> <code>FileRefOrResource</code> <p>FileRefOrResource provides a reference to the file containing the resources to be created.</p> <code>dryRun</code> <code>bool</code> <p>DryRun determines whether the file should be applied in dry run mode.</p> <code>check</code> <code>github.com/kyverno/kyverno-json/pkg/apis/v1alpha1.Any</code> <p>Check is an assertion tree to validate outcome.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Delete","title":"<code>Delete</code>","text":"<p>Appears in:</p> <ul> <li>Operation</li> </ul> <p>Delete is a reference to an object that should be deleted</p> Field Type Required Inline Description <code>ObjectReference</code> <code>ObjectReference</code> <p>ObjectReference determines objects to be deleted.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Error","title":"<code>Error</code>","text":"<p>Appears in:</p> <ul> <li>Operation</li> </ul> <p>Error represents an anticipated error condition that may arise during testing. Instead of treating such an error as a test failure, it acknowledges it as expected.</p> Field Type Required Inline Description <code>FileRef</code> <code>FileRef</code> <p>FileRef provides a reference to the file containing the expected error.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Events","title":"<code>Events</code>","text":"<p>Appears in:</p> <ul> <li>Catch</li> <li>Finally</li> </ul> <p>Events defines how to collects events.</p> Field Type Required Inline Description <code>namespace</code> <code>string</code> <p>Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</p> <code>name</code> <code>string</code> <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>selector</code> <code>string</code> <p>Selector defines labels selector.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-FileRef","title":"<code>FileRef</code>","text":"<p>Appears in:</p> <ul> <li>Assert</li> <li>Error</li> <li>FileRefOrResource</li> </ul> <p>FileRef represents a file reference.</p> Field Type Required Inline Description <code>file</code> <code>string</code> <p>File is the path to the referenced file.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-FileRefOrResource","title":"<code>FileRefOrResource</code>","text":"<p>Appears in:</p> <ul> <li>Apply</li> <li>Create</li> </ul> <p>FileRefOrResource represents a file reference or resource.</p> Field Type Required Inline Description <code>FileRef</code> <code>FileRef</code> <p>FileRef provides a reference to the file containing the resources to be applied.</p> <code>resource</code> <code>meta/v1/unstructured.Unstructured</code> <p>Resource provides a resource to be applied.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Finally","title":"<code>Finally</code>","text":"<p>Appears in:</p> <ul> <li>TestStepSpec</li> </ul> <p>Finally defines actions to be executed at the end of a test.</p> Field Type Required Inline Description <code>timeout</code> <code>meta/v1.Duration</code> <p>Timeout for the operation. Overrides the global timeout set in the Configuration.</p> <code>podLogs</code> <code>PodLogs</code> <p>PodLogs determines the pod logs collector to execute.</p> <code>events</code> <code>Events</code> <p>Events determines the events collector to execute.</p> <code>command</code> <code>Command</code> <p>Command defines a command to run.</p> <code>script</code> <code>Script</code> <p>Script defines a script to run.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-ObjectReference","title":"<code>ObjectReference</code>","text":"<p>Appears in:</p> <ul> <li>Delete</li> </ul> <p>ObjectReference represents one or more objects with a specific apiVersion and kind. For a single object name and namespace are used to identify the object. For multiple objects use labels.</p> Field Type Required Inline Description <code>ObjectSelector</code> <code>ObjectSelector</code> <p>ObjectSelector determines the selection process of referenced objects.</p> <code>apiVersion</code> <code>string</code> <p>API version of the referent.</p> <code>kind</code> <code>string</code> <p>Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-ObjectSelector","title":"<code>ObjectSelector</code>","text":"<p>Appears in:</p> <ul> <li>ObjectReference</li> </ul> <p>ObjectSelector represents a strategy to select objects. For a single object name and namespace are used to identify the object. For multiple objects use labels.</p> Field Type Required Inline Description <code>namespace</code> <code>string</code> <p>Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</p> <code>name</code> <code>string</code> <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>labels</code> <code>map[string]string</code> <p>Label selector to match objects to delete</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Operation","title":"<code>Operation</code>","text":"<p>Appears in:</p> <ul> <li>TestStepSpec</li> </ul> <p>Operation defines a single operation, only one action is permitted for a given operation.</p> Field Type Required Inline Description <code>timeout</code> <code>meta/v1.Duration</code> <p>Timeout for the operation. Overrides the global timeout set in the Configuration.</p> <code>continueOnError</code> <code>bool</code> <p>ContinueOnError determines whether a test should continue or not in case the operation was not successful. Even if the test continues executing, it will still be reported as failed.</p> <code>apply</code> <code>Apply</code> <p>Apply represents resources that should be applied for this test step. This can include things like configuration settings or any other resources that need to be available during the test.</p> <code>assert</code> <code>Assert</code> <p>Assert represents an assertion to be made. It checks whether the conditions specified in the assertion hold true.</p> <code>command</code> <code>Command</code> <p>Command defines a command to run.</p> <code>create</code> <code>Create</code> <p>Create represents a creation operation.</p> <code>delete</code> <code>Delete</code> <p>Delete represents a creation operation.</p> <code>error</code> <code>Error</code> <p>Error represents the expected errors for this test step. If any of these errors occur, the test will consider them as expected; otherwise, they will be treated as test failures.</p> <code>script</code> <code>Script</code> <p>Script defines a script to run.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-PodLogs","title":"<code>PodLogs</code>","text":"<p>Appears in:</p> <ul> <li>Catch</li> <li>Finally</li> </ul> <p>PodLogs defines how to collects pod logs.</p> Field Type Required Inline Description <code>namespace</code> <code>string</code> <p>Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/</p> <code>name</code> <code>string</code> <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>selector</code> <code>string</code> <p>Selector defines labels selector.</p> <code>container</code> <code>string</code> <p>Container in pod to get logs from else --all-containers is used.</p> <code>tail</code> <code>int</code> <p>Tail is the number of last lines to collect from pods. If omitted or zero, then the default is 10 if you use a selector, or -1 (all) if you use a pod name. This matches default behavior of <code>kubectl logs</code>.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-ReportFormatType","title":"<code>ReportFormatType</code>","text":"<p>(Alias of <code>string</code>)</p> <p>Appears in:</p> <ul> <li>ConfigurationSpec</li> </ul>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Script","title":"<code>Script</code>","text":"<p>Appears in:</p> <ul> <li>Catch</li> <li>Finally</li> <li>Operation</li> </ul> <p>Script describes a script to run as a part of a test step.</p> Field Type Required Inline Description <code>content</code> <code>string</code> <p>Content defines a shell script (run with \"sh -c ...\").</p> <code>skipLogOutput</code> <code>bool</code> <p>SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.</p> <code>check</code> <code>github.com/kyverno/kyverno-json/pkg/apis/v1alpha1.Any</code> <p>Check is an assertion tree to validate outcome.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-TestSpec","title":"<code>TestSpec</code>","text":"<p>Appears in:</p> <ul> <li>Test</li> </ul> <p>TestSpec contains the test spec.</p> Field Type Required Inline Description <code>timeouts</code> <code>Timeouts</code> <p>Timeouts for the test. Overrides the global timeouts set in the Configuration on a per operation basis.</p> <code>skip</code> <code>bool</code> <p>Skip determines whether the test should skipped.</p> <code>concurrent</code> <code>bool</code> <p>Concurrent determines whether the test should run concurrently with other tests.</p> <code>skipDelete</code> <code>bool</code> <p>SkipDelete determines whether the resources created by the test should be deleted after the test is executed.</p> <code>namespace</code> <code>string</code> <p>Namespace determines whether the test should run in a random ephemeral namespace or not.</p> <code>steps</code> <code>[]TestSpecStep</code> <p>Steps defining the test.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-TestSpecStep","title":"<code>TestSpecStep</code>","text":"<p>Appears in:</p> <ul> <li>TestSpec</li> </ul> <p>TestSpecStep contains the test step definition used in a test spec.</p> Field Type Required Inline Description <code>name</code> <code>string</code> <p>Name of the step.</p> <code>Spec</code> <code>TestStepSpec</code> <p>Spec of the step.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-TestStepSpec","title":"<code>TestStepSpec</code>","text":"<p>Appears in:</p> <ul> <li>TestStep</li> <li>TestSpecStep</li> </ul> <p>TestStepSpec defines the desired state and behavior for each test step.</p> Field Type Required Inline Description <code>timeouts</code> <code>Timeouts</code> <p>Timeouts for the test step. Overrides the global timeouts set in the Configuration and the timeouts eventually set in the Test.</p> <code>skipDelete</code> <code>bool</code> <p>SkipDelete determines whether the resources created by the step should be deleted after the test step is executed.</p> <code>try</code> <code>[]Operation</code> <p>Try defines what the step will try to execute.</p> <code>catch</code> <code>[]Catch</code> <p>Catch defines what the step will execute when an error happens.</p> <code>finally</code> <code>[]Finally</code> <p>Finally defines what the step will execute after the step is terminated.</p>"},{"location":"apis/chainsaw.v1alpha1/#chainsaw-kyverno-io-v1alpha1-Timeouts","title":"<code>Timeouts</code>","text":"<p>Appears in:</p> <ul> <li>ConfigurationSpec</li> <li>TestSpec</li> <li>TestStepSpec</li> </ul> <p>Timeouts contains timeouts per operation.</p> Field Type Required Inline Description <code>apply</code> <code>meta/v1.Duration</code> <p>Apply defines the timeout for the apply operation</p> <code>assert</code> <code>meta/v1.Duration</code> <p>Assert defines the timeout for the assert operation</p> <code>error</code> <code>meta/v1.Duration</code> <p>Error defines the timeout for the error operation</p> <code>delete</code> <code>meta/v1.Duration</code> <p>Delete defines the timeout for the delete operation</p> <code>cleanup</code> <code>meta/v1.Duration</code> <p>Cleanup defines the timeout for the cleanup operation</p> <code>exec</code> <code>meta/v1.Duration</code> <p>Exec defines the timeout for exec operations</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/","title":"How to Perform Efficient E2E Testing with Chainsaw","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#introduction","title":"Introduction","text":"<p>Chainsaw is a powerful tool that enables efficient end-to-end (E2E) testing, making it an essential asset for software developers. Built to be stronger and more cohesive than KUTTL, Chainsaw offers a superior suite of features for Kubernetes (k8s) operators and objects. In this blog post, we will explore how to leverage Chainsaw for efficient E2E testing and enhance your overall testing workflow. Let's dive in!</p>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#table-of-contents","title":"Table of Contents","text":"<ul> <li>How to Perform Efficient E2E Testing with Chainsaw</li> <li>Introduction</li> <li>Table of Contents<ul> <li>Section 1: Installing Chainsaw</li> <li>1.1 Downloading Chainsaw</li> <li>1.2 Installing Chainsaw</li> <li>Section 2: Writing Configurations</li> <li>2.1 Understanding Chainsaw Configurations</li> <li>2.2 Writing Chainsaw Configurations</li> <li>Section 3: Creating Tests</li> <li>3.1 Understanding Chainsaw Tests</li> <li>3.2 Creating Chainsaw Tests</li> <li>Section 4: Running Tests</li> <li>4.1 Preparing for Test Execution</li> <li>4.2 Executing Tests in Chainsaw</li> <li>Conclusion</li> </ul> </li> </ul>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#section-1-installing-chainsaw","title":"Section 1: Installing Chainsaw","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#11-downloading-chainsaw","title":"1.1 Downloading Chainsaw","text":"<p>To get started with Chainsaw, you'll first need to download the appropriate release for your operating system and architecture. The releases are available on the official GitHub page at the following link: Release</p> <p>Here's a breakdown of the available releases:</p> <ul> <li>For macOS (Darwin) Users:</li> <li>Intel-based Macs: <code>chainsaw_darwin_amd64.tar.gz</code></li> <li> <p>Apple Silicon Macs: <code>chainsaw_darwin_arm64.tar.gz</code></p> </li> <li> <p>For Linux Users:</p> </li> <li>32-bit: <code>chainsaw_linux_386.tar.gz</code></li> <li>64-bit (AMD): <code>chainsaw_linux_amd64.tar.gz</code></li> <li>64-bit (ARM): <code>chainsaw_linux_arm64.tar.gz</code></li> </ul> <p>Each release also comes with associated .pem, .sbom, .sbom.pem, and .sig files. These are used for verification and security purposes. If you're interested in verifying the integrity of your download, you can use these files. However, for the purpose of this guide, we'll focus on the main .tar.gz files.</p>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#12-installing-chainsaw","title":"1.2 Installing Chainsaw","text":"<p>Once you've downloaded the appropriate .tar.gz file for your system, you can proceed with the installation. Here's a step-by-step guide:</p> <ul> <li>Extract the Tarball:</li> </ul> <pre><code>tar -xzf chainsaw_&lt;your_version_and_architecture&gt;.tar.gz\n</code></pre> <ul> <li>Move the Extracted Binary:</li> </ul> <pre><code>sudo mv chainsaw /usr/local/bin/\n</code></pre> <ul> <li>Verify the Installation:</li> </ul> <pre><code>chainsaw --version\n</code></pre>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#section-2-writing-configurations","title":"Section 2: Writing Configurations","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#21-understanding-chainsaw-configurations","title":"2.1 Understanding Chainsaw Configurations","text":"<p>Chainsaw is a robust tool for end-to-end (e2e) testing in Kubernetes environments. It offers a flexible configuration system that allows users to define their testing parameters and conditions. The configuration can be set up in two primary ways:</p> <ul> <li>Configuration File: This is a structured file where you can define all your testing parameters.</li> <li>Command-line Flags: These are options you can pass directly when running Chainsaw commands. If both a configuration file and command-line flags are provided, the flags will override the settings in the configuration file.</li> </ul> <p>Chainsaw follows a hierarchy in loading its configurations:</p> <ol> <li>User-specified Configuration: If you provide a configuration file explicitly using a command-line flag.</li> <li>Default Configuration File: If no configuration is specified, Chainsaw will search for a default file named .chainsaw.yaml in the current directory.</li> <li>Internal Default Configuration: If neither of the above is available, Chainsaw will resort to a default configuration embedded within its binary.</li> </ol> <p>To specify a custom configuration, use the following command:</p> <pre><code>chainsaw test --config path/to/your/config.yaml\n</code></pre>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#22-writing-chainsaw-configurations","title":"2.2 Writing Chainsaw Configurations","text":"<p>When writing a configuration for Chainsaw, you'll be working with a YAML file. Here's a basic example of what this might look like:</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Configuration\nmetadata:\n  name: custom-config\nspec:\n  timeout: 45s\n  skipDelete: false\n  failFast: true\n  parallel: 4\n  # ... other configurations\n</code></pre> <p>The full structure of the configuration file, including all possible fields and their descriptions, can be found in the Configuration API reference.</p> <p>If you don't provide a custom configuration, Chainsaw will use its default:</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Configuration\nmetadata:\n  name: default\nspec: {}\n</code></pre> <p>You can also override specific configurations using command-line flags, even after loading a configuration file. For instance:</p> <pre><code>chainsaw test --config path/to/your/config.yaml --timeout 45s --parallel 4\n</code></pre> <p>In this example, even if the configuration file specifies different values for <code>timeout</code> and <code>parallel</code>, the command-line flags will take precedence.</p> <p>For a comprehensive list of all supported flags and their descriptions, refer to the Chainsaw test command reference.</p>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#section-3-creating-tests","title":"Section 3: Creating Tests","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#31-understanding-chainsaw-tests","title":"3.1 Understanding Chainsaw Tests","text":"<p>In Chainsaw, a test is essentially an ordered sequence of test steps. These steps are executed sequentially, and if any step fails, the entire test is considered failed. Each test step can consist of multiple operations, such as creating, updating, or deleting resources in a Kubernetes cluster, or asserting that certain conditions are met.</p> <p>Chainsaw supports three primary test definition mechanisms:</p> <ul> <li>Manifests based syntax: This is a straightforward method where you provide Kubernetes resource manifests. Chainsaw uses these manifests to create, update, or assert expectations against a cluster.</li> <li>TestSteps based syntax: A more verbose method that offers flexibility in defining each test step. It allows for additional configurations and can be combined with the Manifests based syntax.</li> <li>Test based syntax: The most explicit method that provides a comprehensive overview of the test. It doesn't rely on file naming conventions and offers flexibility at both the test and test step levels.</li> </ul>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#32-creating-chainsaw-tests","title":"3.2 Creating Chainsaw Tests","text":"<p>Creating tests in Chainsaw requires a clear understanding of the test definition mechanisms. Here's a detailed guide for each syntax:</p> <ol> <li>Using Manifests based syntax</li> </ol> <p>File Naming: Files should follow the convention <code>&lt;step index&gt;-&lt;name|assert|error&gt;.yaml</code>. For instance, <code>00-configmap.yaml</code> for resource creation, <code>01-assert.yaml</code> for assertions, and <code>02-error.yaml</code> for expected errors.</p> <p>Example:</p> <pre><code># 00-configmap.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-example\ndata:\n  key: value\n</code></pre> <ol> <li> <p>Using TestSteps based syntax</p> <p>Define a TestStep: Create a YAML file that defines a <code>TestStep</code> resource. This resource should specify operations like <code>Apply</code>, <code>Assert</code>, <code>Delete</code>, and <code>Error</code>.</p> </li> </ol> <p>Example:</p> <pre><code># 01-test-step.yaml\napiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: apply-configmap-step\nspec:\n  apply:\n  - file: /resources/configmap.yaml\n</code></pre> <p>You can combine TestStep resources with raw Kubernetes manifests. For instance, a TestStep might apply a resource, while a separate manifest file makes assertions about that resource.</p> <p>Example:</p> <pre><code># 02-assert.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-example\ndata:\n  key: value\n</code></pre> <ol> <li>Using Test based syntax</li> </ol> <p>Define a Test: Start by creating a YAML file that defines a Test resource. This resource will have a spec section that outlines the entire test.</p> <p>Example:</p> <pre><code># chainsaw-test.yaml\napiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: full-test-example\nspec:\n  timeout: 10s\n  steps:\n  - spec:\n      apply:\n      - file: /resources/configmap.yaml\n  - spec:\n      assert:\n      - file: /resources/configmap-assert.yaml\n</code></pre> <p>Chainsaw processes the test by executing each step in sequence, ensuring that your Kubernetes environment meets the defined conditions.</p>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#section-4-running-tests","title":"Section 4: Running Tests","text":""},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#41-preparing-for-test-execution","title":"4.1 Preparing for Test Execution","text":"<p>Before executing your tests, ensure that:</p> <ol> <li>Kubernetes Cluster: You have access to a Kubernetes cluster where the tests will run. This could be a local cluster (like Minikube or kind) or a remote one.</li> <li>Kubeconfig: Your <code>kubeconfig</code> is correctly set up to point to the desired cluster. Chainsaw will use the current context from your <code>kubeconfig</code> to interact with the cluster.</li> <li>Test Files: All your test files, whether they are written using Manifests based, <code>TestSteps</code> based, or <code>Test</code> based syntax, are organized and accessible.</li> </ol>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#42-executing-tests-in-chainsaw","title":"4.2 Executing Tests in Chainsaw","text":"<p>Once you're set up, running tests in Chainsaw is straightforward:</p> <ol> <li>Navigate to the Test Directory:</li> </ol> <pre><code>cd path/to/your/test/directory\n</code></pre> <ol> <li>Run the Tests:</li> </ol> <pre><code>chainsaw test\n</code></pre> <p>This command will execute all tests in the current directory.</p> <ol> <li>View the Results: Chainsaw will display the results in the terminal. It provides a summary of passed, failed, and skipped tests. For any failed tests, Chainsaw will display detailed error messages to help diagnose the issue.</li> </ol> <p>The output will resemble:</p> <pre><code>Loading default configuration...\n...\nRunning tests...\n=== RUN   quick-start\n...\n--- PASS: quick-start (5.22s)\nPASS\nTests Summary...\n- Passed  tests: 3\n- Failed  tests: 1\n- Skipped tests: 2\nDone.\n</code></pre>"},{"location":"blog/How-to-Perform-Efficient-E2E-Testing-with-Chainsaw/#conclusion","title":"Conclusion","text":"<p>Chainsaw provides a robust and flexible framework for end-to-end testing in Kubernetes environments. By understanding its configuration and test definition mechanisms, developers can create comprehensive test suites that ensure their Kubernetes applications and configurations are functioning as expected.</p>"},{"location":"blog/first-test/","title":"First working test !","text":"<p>First test run !</p> <p>The quick start test is passing </p> <pre><code># define kind image\nexport KIND_IMAGE=\"kindest/node:v1.28.0\"\n\n# create cluster\nkind create cluster --image $KIND_IMAGE\n\n# create test folder\nmkdir quick-start\n\n# enter test folder\ncd quick-start\n\n# create a ConfigMap\ncat &gt; configmap.yaml &lt;&lt; EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\nEOF\n\n# create test file\ncat &gt; chainsaw-test.yaml &lt;&lt; EOF\napiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: quick-start\nspec:\n  steps:\n  # first step applies the config map\n  - apply:\n    # file is relative to the test folder\n    - file: configmap.yaml\n  # second step verifies the config map exists and contains the expected data\n  - assert:\n    # file is relative to the test folder\n    - file: configmap.yaml\nEOF\n\n../chainsaw test --test-dir .\n\nRunning without configuration\nLoading tests...\n- quick-start (.)\nRunning tests...\n=== RUN   chainsaw\n=== RUN   chainsaw/quick-start\n=== PAUSE chainsaw/quick-start\n=== CONT  chainsaw/quick-start\n    runner.go:35: step-1\n    runner.go:35: apply chainsaw-polite-chamois/chainsaw-quick-start (v1/ConfigMap)\n    runner.go:35: step-2\n    runner.go:35: assert chainsaw-polite-chamois/chainsaw-quick-start (v1/ConfigMap)\n    runner.go:68: cleanup namespace: chainsaw-polite-chamois\n--- PASS: chainsaw (0.00s)\n    --- PASS: chainsaw/quick-start (5.09s)\nPASS\nDone.\n</code></pre> <p>Impressive ! </p>"},{"location":"blog/wip/","title":"It's happening - Finally !","text":"<p>Hello everyone!</p> <p>We finally started writing our own testing tool !</p> <p>Let's join forces and make better, stronger Open Source and Community Driven tool.</p>"},{"location":"blog/wip/#why-we-made-it","title":"Why we made it ?","text":"<p>While developing Kyverno we needed to run end to end tests to make sure our admission controller worked as expected.</p> <p>Kyverno can validate, mutate and generate resources based on policies installed in a cluster and a typical test is:</p> <ol> <li>Create a policy</li> <li>Create a resource</li> <li>Check that Kyverno acted as expected</li> <li>Cleanup and move to the next test</li> </ol> <p>We started with another tool called KUTTL. While KUTTL is great we identified some limitations and forked the tool to add the features we needed.</p> <p>At some point we needed more flexibility than what KUTTL offered and we designed a new assertion model.</p> <p>This was simpler to start from scratch than continuing making changes in our KUTTL fork.</p>"},{"location":"blog/wip/#whats-next","title":"What's next ?","text":"<p>This is still WIP and needs a lot of work before we can consider it ready but things are moving fast.</p> <p>We would love to build a community driven tool and welcome all contributors.</p> <p>Feel free to fork this repository and start submitting pull requests </p>"},{"location":"commands/chainsaw/","title":"Chainsaw","text":""},{"location":"commands/chainsaw/#chainsaw","title":"chainsaw","text":"<p>Stronger tool for e2e testing</p> <pre><code>chainsaw [flags]\n</code></pre>"},{"location":"commands/chainsaw/#options","title":"Options","text":"<pre><code>  -h, --help   help for chainsaw\n</code></pre>"},{"location":"commands/chainsaw/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw completion  - Generate the autocompletion script for the specified shell</li> <li>chainsaw docs  - Generate reference documentation</li> <li>chainsaw kuttl    - Work with KUTTL tests</li> <li>chainsaw test  - Run tests</li> <li>chainsaw version    - Print the version informations</li> </ul>"},{"location":"commands/chainsaw_completion/","title":"Chainsaw completion","text":""},{"location":"commands/chainsaw_completion/#chainsaw-completion","title":"chainsaw completion","text":"<p>Generate the autocompletion script for the specified shell</p>"},{"location":"commands/chainsaw_completion/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for chainsaw for the specified shell. See each sub-command's help for details on how to use the generated script.</p>"},{"location":"commands/chainsaw_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"commands/chainsaw_completion/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw    - Stronger tool for e2e testing</li> <li>chainsaw completion bash    - Generate the autocompletion script for bash</li> <li>chainsaw completion fish    - Generate the autocompletion script for fish</li> <li>chainsaw completion powershell    - Generate the autocompletion script for powershell</li> <li>chainsaw completion zsh  - Generate the autocompletion script for zsh</li> </ul>"},{"location":"commands/chainsaw_completion_bash/","title":"Chainsaw completion bash","text":""},{"location":"commands/chainsaw_completion_bash/#chainsaw-completion-bash","title":"chainsaw completion bash","text":"<p>Generate the autocompletion script for bash</p>"},{"location":"commands/chainsaw_completion_bash/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the bash shell.</p> <p>This script depends on the 'bash-completion' package. If it is not installed already, you can install it via your OS's package manager.</p> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(chainsaw completion bash)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"commands/chainsaw_completion_bash/#linux","title":"Linux:","text":"<pre><code>chainsaw completion bash &gt; /etc/bash_completion.d/chainsaw\n</code></pre>"},{"location":"commands/chainsaw_completion_bash/#macos","title":"macOS:","text":"<pre><code>chainsaw completion bash &gt; $(brew --prefix)/etc/bash_completion.d/chainsaw\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>chainsaw completion bash\n</code></pre>"},{"location":"commands/chainsaw_completion_bash/#options","title":"Options","text":"<pre><code>  -h, --help              help for bash\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"commands/chainsaw_completion_bash/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"commands/chainsaw_completion_fish/","title":"Chainsaw completion fish","text":""},{"location":"commands/chainsaw_completion_fish/#chainsaw-completion-fish","title":"chainsaw completion fish","text":"<p>Generate the autocompletion script for fish</p>"},{"location":"commands/chainsaw_completion_fish/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the fish shell.</p> <p>To load completions in your current shell session:</p> <pre><code>chainsaw completion fish | source\n</code></pre> <p>To load completions for every new session, execute once:</p> <pre><code>chainsaw completion fish &gt; ~/.config/fish/completions/chainsaw.fish\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>chainsaw completion fish [flags]\n</code></pre>"},{"location":"commands/chainsaw_completion_fish/#options","title":"Options","text":"<pre><code>  -h, --help              help for fish\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"commands/chainsaw_completion_fish/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"commands/chainsaw_completion_powershell/","title":"Chainsaw completion powershell","text":""},{"location":"commands/chainsaw_completion_powershell/#chainsaw-completion-powershell","title":"chainsaw completion powershell","text":"<p>Generate the autocompletion script for powershell</p>"},{"location":"commands/chainsaw_completion_powershell/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for powershell.</p> <p>To load completions in your current shell session:</p> <pre><code>chainsaw completion powershell | Out-String | Invoke-Expression\n</code></pre> <p>To load completions for every new session, add the output of the above command to your powershell profile.</p> <pre><code>chainsaw completion powershell [flags]\n</code></pre>"},{"location":"commands/chainsaw_completion_powershell/#options","title":"Options","text":"<pre><code>  -h, --help              help for powershell\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"commands/chainsaw_completion_powershell/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"commands/chainsaw_completion_zsh/","title":"Chainsaw completion zsh","text":""},{"location":"commands/chainsaw_completion_zsh/#chainsaw-completion-zsh","title":"chainsaw completion zsh","text":"<p>Generate the autocompletion script for zsh</p>"},{"location":"commands/chainsaw_completion_zsh/#synopsis","title":"Synopsis","text":"<p>Generate the autocompletion script for the zsh shell.</p> <p>If shell completion is not already enabled in your environment you will need to enable it.  You can execute the following once:</p> <pre><code>echo \"autoload -U compinit; compinit\" &gt;&gt; ~/.zshrc\n</code></pre> <p>To load completions in your current shell session:</p> <pre><code>source &lt;(chainsaw completion zsh)\n</code></pre> <p>To load completions for every new session, execute once:</p>"},{"location":"commands/chainsaw_completion_zsh/#linux","title":"Linux:","text":"<pre><code>chainsaw completion zsh &gt; \"${fpath[1]}/_chainsaw\"\n</code></pre>"},{"location":"commands/chainsaw_completion_zsh/#macos","title":"macOS:","text":"<pre><code>chainsaw completion zsh &gt; $(brew --prefix)/share/zsh/site-functions/_chainsaw\n</code></pre> <p>You will need to start a new shell for this setup to take effect.</p> <pre><code>chainsaw completion zsh [flags]\n</code></pre>"},{"location":"commands/chainsaw_completion_zsh/#options","title":"Options","text":"<pre><code>  -h, --help              help for zsh\n      --no-descriptions   disable completion descriptions\n</code></pre>"},{"location":"commands/chainsaw_completion_zsh/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw completion  - Generate the autocompletion script for the specified shell</li> </ul>"},{"location":"commands/chainsaw_docs/","title":"Chainsaw docs","text":""},{"location":"commands/chainsaw_docs/#chainsaw-docs","title":"chainsaw docs","text":"<p>Generate reference documentation</p> <pre><code>chainsaw docs [flags]\n</code></pre>"},{"location":"commands/chainsaw_docs/#options","title":"Options","text":"<pre><code>      --autogenTag      Determines if the generated docs should contain a timestamp (default true)\n  -h, --help            help for docs\n  -o, --output string   Output path (default \".\")\n      --website         Website version\n</code></pre>"},{"location":"commands/chainsaw_docs/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw    - Stronger tool for e2e testing</li> </ul>"},{"location":"commands/chainsaw_kuttl/","title":"Chainsaw kuttl","text":""},{"location":"commands/chainsaw_kuttl/#chainsaw-kuttl","title":"chainsaw kuttl","text":"<p>Work with KUTTL tests</p> <pre><code>chainsaw kuttl [flags]\n</code></pre>"},{"location":"commands/chainsaw_kuttl/#options","title":"Options","text":"<pre><code>  -h, --help   help for kuttl\n</code></pre>"},{"location":"commands/chainsaw_kuttl/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw    - Stronger tool for e2e testing</li> <li>chainsaw kuttl migrate    - Migrate KUTTL tests to Chainsaw</li> </ul>"},{"location":"commands/chainsaw_kuttl_migrate/","title":"Chainsaw kuttl migrate","text":""},{"location":"commands/chainsaw_kuttl_migrate/#chainsaw-kuttl-migrate","title":"chainsaw kuttl migrate","text":"<p>Migrate KUTTL tests to Chainsaw</p> <pre><code>chainsaw kuttl migrate [flags]\n</code></pre>"},{"location":"commands/chainsaw_kuttl_migrate/#options","title":"Options","text":"<pre><code>  -h, --help        help for migrate\n      --overwrite   If set, overwrites original file.\n      --save        If set, converted files will be saved.\n</code></pre>"},{"location":"commands/chainsaw_kuttl_migrate/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw kuttl    - Work with KUTTL tests</li> </ul>"},{"location":"commands/chainsaw_test/","title":"Chainsaw test","text":""},{"location":"commands/chainsaw_test/#chainsaw-test","title":"chainsaw test","text":"<p>Run tests</p> <pre><code>chainsaw test [flags]... [test directories]...\n</code></pre>"},{"location":"commands/chainsaw_test/#options","title":"Options","text":"<pre><code>      --apply-timeout duration              The apply timeout to use as default for configuration. (default 5s)\n      --assert-timeout duration             The assert timeout to use as default for configuration. (default 30s)\n      --cleanup-timeout duration            The cleanup timeout to use as default for configuration. (default 30s)\n      --config string                       Chainsaw configuration file.\n      --delete-timeout duration             The delete timeout to use as default for configuration. (default 15s)\n      --error-timeout duration              The error timeout to use as default for configuration. (default 30s)\n      --exclude-test-regex string           Regular expression to exclude tests.\n      --exec-timeout duration               The exec timeout to use as default for configuration. (default 5s)\n      --fail-fast                           Stop the test upon encountering the first failure.\n      --full-name                           Use full test case folder path instead of folder name.\n  -h, --help                                help for test\n      --include-test-regex string           Regular expression to include tests.\n      --kube-as string                      Username to impersonate for the operation\n      --kube-as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --kube-as-uid string                  UID to impersonate for the operation\n      --kube-certificate-authority string   Path to a cert file for the certificate authority\n      --kube-client-certificate string      Path to a client certificate file for TLS\n      --kube-client-key string              Path to a client key file for TLS\n      --kube-cluster string                 The name of the kubeconfig cluster to use\n      --kube-context string                 The name of the kubeconfig context to use\n      --kube-disable-compression            If true, opt-out of response compression for all requests to the server\n      --kube-insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -n, --kube-namespace string               If present, the namespace scope for this CLI request\n      --kube-password string                Password for basic authentication to the API server\n      --kube-proxy-url string               If provided, this URL will be used to connect via proxy\n      --kube-request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --kube-server string                  The address and port of the Kubernetes API server\n      --kube-tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --kube-token string                   Bearer token for authentication to the API server\n      --kube-user string                    The name of the kubeconfig user to use\n      --kube-username string                Username for basic authentication to the API server\n      --namespace string                    Namespace to use for tests.\n      --no-color                            Removes output colors.\n      --parallel int                        The maximum number of tests to run at once.\n      --repeat-count int                    Number of times to repeat each test. (default 1)\n      --report-format string                Test report format (JSON|XML|nil).\n      --report-name string                  The name of the report to create. (default \"chainsaw-report\")\n      --skip-delete                         If set, do not delete the resources after running the tests.\n      --test-dir stringArray                Directories containing test cases to run.\n      --test-file string                    Name of the test file. (default \"chainsaw-test.yaml\")\n</code></pre>"},{"location":"commands/chainsaw_test/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw    - Stronger tool for e2e testing</li> </ul>"},{"location":"commands/chainsaw_version/","title":"Chainsaw version","text":""},{"location":"commands/chainsaw_version/#chainsaw-version","title":"chainsaw version","text":"<p>Print the version informations</p> <pre><code>chainsaw version [flags]\n</code></pre>"},{"location":"commands/chainsaw_version/#options","title":"Options","text":"<pre><code>  -h, --help   help for version\n</code></pre>"},{"location":"commands/chainsaw_version/#see-also","title":"SEE ALSO","text":"<ul> <li>chainsaw    - Stronger tool for e2e testing</li> </ul>"},{"location":"more/crds/","title":"Custom resource definitions","text":"<p>New Custom Resource Definitions are not immediately available for use in the Kubernetes API until the Kubernetes API has acknowledged them.</p> <p>If a Custom Resource Definition is being defined inside of a test step, be sure to to wait for the CustomResourceDefinition object to appear.</p> <p>For example, given this Custom Resource Definition:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1beta1\nkind: CustomResourceDefinition\nmetadata:\n  name: mycrds.mycrd.k8s.io\nspec:\n  group: mycrd.k8s.io\n  version: v1alpha1\n  names:\n    kind: MyCRD\n    listKind: MyCRDList\n    plural: mycrds\n    singular: mycrd\n  scope: Namespaced\n</code></pre> <p>Create the following assert:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1beta1\nkind: CustomResourceDefinition\nmetadata:\n  name: mycrds.mycrd.k8s.io\nstatus:\n  acceptedNames:\n    kind: MyCRD\n    listKind: MyCRDList\n    plural: mycrds\n    singular: mycrd\n  storedVersions:\n  - v1alpha1\n</code></pre> <p>And then the CRD can be used in subsequent steps:</p> <pre><code>apiVersion: mycrd.k8s.io/v1alpha1\nkind: MyCRD\nmetadata:\n  name: my-crds\nspec:\n  test: test\n</code></pre>"},{"location":"more/events/","title":"Kubernetes events","text":"<p>Kubernetes events are regular Kubernetes objects and can be asserted on just like any other object:</p> <pre><code>apiVersion: v1\nkind: Event\nreason: Started\nsource:\n  component: kubelet\ninvolvedObject:\n  apiVersion: v1\n  kind: Pod\n  name: my-pod\n</code></pre>"},{"location":"more/ide-completion/","title":"IDE completion","text":"<p>While there is no currently available Kubernetes controller to handle the Chainsaw configuration files, the CRD definitions may be handy for users to leverage coding assistance in their favorite IDE.</p>"},{"location":"more/ide-completion/#crd-definitions","title":"CRD definitions","text":"<p>CRD definitions are provided in our GitHub repository.</p>"},{"location":"more/ide-completion/#apply-in-cluster","title":"Apply in cluster","text":"<p>If necessary, CRDs can be registered in your cluster with:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kyverno/chainsaw/main/config/crds/chainsaw.kyverno.io_configurations.yaml\nkubectl apply -f https://raw.githubusercontent.com/kyverno/chainsaw/main/config/crds/chainsaw.kyverno.io_tests.yaml\nkubectl apply -f https://raw.githubusercontent.com/kyverno/chainsaw/main/config/crds/chainsaw.kyverno.io_teststeps.yaml\n</code></pre>"},{"location":"more/kuttl-migration/","title":"Migration from KUTTL","text":""},{"location":"more/kuttl-migration/#overview","title":"Overview","text":"<p>The <code>chainsaw kuttl migrate</code> command is designed for the migration of KUTTL tests to Chainsaw. When executed, the command looks for KUTTL-defined tests and attempts to convert these into the equivalent Chainsaw-defined tests.</p>"},{"location":"more/kuttl-migration/#usage","title":"Usage","text":"<pre><code>chainsaw kuttl migrate [flags]\n</code></pre>"},{"location":"more/kuttl-migration/#options","title":"Options","text":"<pre><code>  -h, --help        help for migrate\n      --overwrite   If set, overwrites original file.\n      --save        If set, converted files will be saved.\n</code></pre> <p>Note</p> <p>You can view the full command documentation here.</p>"},{"location":"more/kuttl-migration/#example","title":"Example","text":"<p>The command below will migrate KUTTL tests to Chainsaw and overwrite original files with converted ones.</p> <pre><code>chainsaw kuttl migrate --save --overwrite path/to/kuttl/tests\n</code></pre>"},{"location":"more/kuttl-migration/#description","title":"Description","text":"<p>On invocation, the command:</p> <ul> <li>Discovers folders from the specified paths.</li> <li>Reads the files within these folders, specifically looking for YAML files.</li> <li>Inspects each YAML file to check if it's a KUTTL resource. If it is, the command tries to convert it to a Chainsaw resource.</li> <li>The conversion handles two types of KUTTL resources: TestSuite and TestStep. It also reports an error for unsupported resources like <code>TestAssert</code>.</li> <li>If the <code>--save</code> flag is set, the converted Chainsaw tests are saved to a new file with the extension <code>.chainsaw.yaml</code>.</li> <li>If the <code>--save</code> and <code>--overwrite</code> flags are set, the converted Chainsaw tests are saved to the same file as the original one.</li> </ul>"},{"location":"more/kuttl-migration/#implementation-details","title":"Implementation details","text":""},{"location":"more/kuttl-migration/#discover-folders","title":"Discover Folders","text":"<p>The command finds folders in the specified paths.</p>"},{"location":"more/kuttl-migration/#file-inspection","title":"File Inspection","text":"<p>It filters out non-YAML files and directories, focusing only on YAML files which might contain KUTTL test definitions.</p>"},{"location":"more/kuttl-migration/#resource-conversion","title":"Resource Conversion","text":"<p>For identified KUTTL resources:</p> <ul> <li><code>TestSuite</code> is converted to Chainsaw's <code>Configuration</code> resource.</li> <li><code>TestStep</code> is converted to Chainsaw's <code>TestStep</code> resource.</li> </ul>"},{"location":"more/kuttl-migration/#save-converted-tests","title":"Save Converted Tests","text":"<p>If the <code>--save</code> flag is provided and if any resource within the YAML file needs saving (as determined by the migration process), the converted tests are saved.</p> <p>The file path for saving is determined by the <code>--overwrite</code> flag; if it is set, the original file will be overwritten, else a new <code>.chainsaw.yaml</code> file will be created.</p>"},{"location":"more/kuttl-migration/#current-limitations","title":"Current limitations","text":"<p>The migration command has the following limitations:</p> <ul> <li>Converting <code>TestAssert</code> resources is not supported (yet)</li> <li>Some fileds in KUTTL <code>command</code> are not supported and will raise an error</li> </ul>"},{"location":"tests/","title":"What is Chainsaw","text":""},{"location":"tests/#overview","title":"Overview","text":"<p>Chainsaw provides a declarative approach to testing production-grade Kubernetes operators and controllers.</p> <p>It provides a way to inject an operator (subject under test) during the setup and allows tests to be standard YAML files.</p> <p>In Chainsaw everything is YAML. We use YAML to manipulate resources, define cluster state assertions, describe commands to run, etc... Everything is declarative.</p>"},{"location":"tests/#motivation","title":"Motivation","text":"<p>Testing Kubernetes operators is not easy.</p> <p>At Kyverno we are building complex controllers and admission controllers that need to be deeply end to end tested.</p> <p>Advantages of a declarative approach</p> <p>It made sense to be able to declaratively create end to end tests for a couple of reasons:</p> <ul> <li>Easily translate a reported issue to an end to end test</li> <li>Add new end to end tests without writing a single line of code</li> </ul>"},{"location":"tests/#when-would-you-use-chainsaw","title":"When would you use Chainsaw","text":"<p>The testing eco-system is vast and includes at a minimum low level unit tests, integration tests and end-to-end testing.</p> <p>Chainsaw is built to support some kubernetes integration test scenarios and is most valuable as an end to end testing tool.</p> <p>Chainsaw is great for</p> <ul> <li>Provide tests against your Custom Resource Definitions (CRDs)</li> <li>Inject a controller and assert states in a running cluster</li> <li>Run same tests against multiple implementations and multiple versions of Kubernetes clusters</li> </ul>"},{"location":"tests/configuration/","title":"Configuration","text":"<p>Chainsaw is a comprehensive tool designed to facilitate end to end testing in Kubernetes.</p> <p>This documentation will focus on providing a breakdown of its configuration structure and how to use it.</p> <p>Chainsaw can be configured in two different and complementary ways:</p> <ul> <li>Using a configuration file</li> <li>Overriding configuration with command-line flags</li> </ul> <p>Tip</p> <p>If both are specified, command-line flags will take precedence over configuration coming from a configuration file.</p>"},{"location":"tests/configuration/#configuration-file","title":"Configuration file","text":""},{"location":"tests/configuration/#overview","title":"Overview","text":"<p>Chainsaw is described as a Stronger tool for e2e testing.</p> <p>With its versatile configuration options, you can customize the testing process to fit your needs.</p> <p>Configuration loading process</p> <p>Chainsaw prioritizes its configuration in the following order:</p> <ol> <li>User-specified configuration: If you explicitly provide a configuration file using a command-line flag.</li> <li>Default configuration file: If no configuration is specified, Chainsaw will look for a default file named <code>.chainsaw.yaml</code> in the current working directory.</li> <li>Internal default configuration: In the absence of both the above, Chainsaw will use a default configuration file embedded in the Chainsaw binary.</li> </ol>"},{"location":"tests/configuration/#how-to-specify-a-configuration","title":"How to specify a configuration","text":"<p>To use a custom configuration file:</p> <pre><code>chainsaw test --config path/to/your/config.yaml\n</code></pre> <p>If you don't specify any configuration, Chainsaw will look for the default configuration file <code>.chainsaw.yaml</code> in the current working directory.</p> <p>If that file is not found, it will fall back to its internal default configuration.</p>"},{"location":"tests/configuration/#timeouts","title":"Timeouts","text":"<p>Timeouts are specified per type of operation:</p> <ul> <li>Apply    - when Chainsaw applies manifests in a cluster</li> <li>Assert   - when Chainsaw validates resources in a cluster</li> <li>Error    - when Chainsaw validates resources in a cluster</li> <li>Delete   - when Chainsaw deletes resources from a cluster</li> <li>Cleanup  - when Chainsaw removes resources from a cluster created for a test</li> <li>Exec     - when Chainsaw executes arbitrary commands or scripts</li> </ul> <p>This is required because the timeout varies greatly depending on the nature of an operation. For example, applying a manifest in a cluster is expected to be reasonably fast, while validating a resource can be a long operation.</p> <p>Overriding timeouts</p> <p>Each timeout can be overridden at the test level, test step level, or individual operation level.</p> <p>Timeouts defined in the <code>Configuration</code> are used when not overridden.</p> <p>See the chainsaw test command line flags for default timeout values.</p>"},{"location":"tests/configuration/#example","title":"Example","text":"<pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Configuration\nmetadata:\n  name: custom-config\nspec:\n  timeouts:\n    apply: 45s\n    delete: 25s\n    assert: 20s\n    error: 10s\n    cleanup: 45s\n    exec: 45s\n  skipDelete: false\n  failFast: true\n  parallel: 4\n  // ....\n</code></pre> <p>The full structure of the configuration file is documented here.</p>"},{"location":"tests/configuration/#default-configuration","title":"Default configuration","text":"<p>The default configuration below is used by Chainsaw when no configuration file was provided and the default file <code>.chainsaw.yaml</code> does not exist.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Configuration\nmetadata:\n  name: default\nspec: {}\n</code></pre>"},{"location":"tests/configuration/#overriding-with-flags","title":"Overriding with flags","text":"<p>Even after a configuration is loaded, you can override specific settings using command-line flags:</p> <pre><code>chainsaw test                           \\\n    --config path/to/your/config.yaml   \\\n    --test-dir path/to/test/dir         \\\n    --assert-timeout 45s                \\\n    --skip-delete false                 \\\n    --fail-fast true                    \\\n    --parallel 4                        \\\n    ...\n</code></pre> <p>In this example, Chainsaw will load a configuration file but the timeout configuration and other settings will be overridden by the values set in the flags, regardless of the value in the loaded configuration file.</p> <p>Supported command line flags are documented here.</p>"},{"location":"tests/configuration/#usage-example","title":"Usage example","text":"<pre><code>chainsaw test --config my-config.yaml --test-dir /path/to/tests --parallel 10\n</code></pre> <p>This command will run tests using the configuration from <code>my-config.yaml</code>, taking tests from <code>/path/to/tests</code>, and running a maximum of <code>10</code> tests simultaneously.</p>"},{"location":"tests/configuration/#reference","title":"Reference","text":"<p>Refer to the reference documentations for details about supported fields in the configuration file and/or supported flags in the <code>test</code> command.</p> <ul> <li>Configuration API reference</li> <li>Chainsaw test command reference</li> </ul>"},{"location":"tests/what-is-a-test/","title":"What is a test","text":"<p>In a nutshell, a test can be represented as an ordered sequence of test steps. Test steps within a test are run sequentially: if any of the test steps fail, the entire test is considered failed.</p> <p>A test step can consist in one or more operations:</p> <ul> <li>To delete resources present in a cluster</li> <li>To create or update resources in a cluster</li> <li>To assert one or more resources in a cluster meet the expectations (or the opposite)</li> <li>To run arbitrary commands or scripts</li> </ul> <p>Try, catch, finally</p> <p>Additionally Chainsaw offers a flexible way to react to errors and/or execute post step operations.</p>"},{"location":"tests/what-is-a-test/#different-syntaxes","title":"Different syntaxes","text":"<p>Chainsaw supports multiple test definition mechanisms. Under certain circumstances, some operations might not be directly available and it might be possible to combine multiple syntaxes together to assemble a test.</p> <ol> <li> <p>Manifests based syntax: This is the simplest and less verbose supported syntax, you provide bare Kubernetes resource manifests and Chainsaw will use those manifests to create, update, or assert expectations against a cluster. While this syntax is simple, it doesn't support deletion for example and doesn't allow specifying additional configuration per test or step. It also relies a lot on file naming conventions and makes it hard to reuse files across multiple tests.</p> </li> <li> <p><code>TestStep</code>s based syntax: This syntax is more verbose than the first one but offers the flexibility to provide additional configuration per test step. It also makes it easier to reuse files accross multiple tests but still relies on the same file naming conventions as the manifests based syntax. On the other hand it doesn't suffer the unsupported deletion limitation and can be combined with manifests based syntax when defining a step.</p> </li> <li> <p><code>Test</code> based syntax: The <code>Test</code> based syntax is the more verbose and explicit syntax. It does not rely on file naming conventions, it makes it easy to reuse files accross multiple tests, and offers the flexibility to provide additional configuration at both the test level and test step level. It supports all kind of operations.</p> </li> </ol> <p>Choosing one syntax over the other is not a trivial choice, every one will have its own preference and/or constraints.</p> <p>If you feel more comfortable with explicit declarative models, the recommandation would be to use <code>Test</code> based syntax.</p> <p>If you don't mind relying on file naming conventions and don't need to reuse files across multiple tests manifests based syntax or <code>TestStep</code>s based syntax is a good choice.</p> <p>Using <code>TestStep</code>s based syntax only is debatable. In this case, <code>Test</code> based syntax could be a simpler choice with more flexibility.</p>"},{"location":"tests/what-is-a-test/#operations","title":"Operations","text":"<p>All operations are explained in the Operations documentation.</p>"},{"location":"tests/what-is-a-test/#cleanup","title":"Cleanup","text":"<p>Unless configured differently, by default Chainsaw will automatically cleanup the resources it created after a test finishes. Cleanup happens in reverse order of creation (created last, cleaned up first).</p> <p>Note that Chainsaw performs a blocking deletion, that is, it will wait the resource is actually not present anymore in the cluster before proceeding with the next resource cleanup.</p> <p>This is important, especially when the controller being tested makes use of <code>finalizers</code>.</p> <p>Overriding cleanup timeout</p> <p>A global cleanup timeout can be defined at the configuration level or using command line flags.</p> <p>It can also be overriden on a per test or per test step basis but not at the operation level.</p>"},{"location":"tests/what-is-a-test/#namespaced-resources","title":"Namespaced resources","text":"<p>Kubernetes organizes resources into two primary scopes: namespaced and cluster-scoped. While namespaced resources belong to a specific namespace, cluster-scoped resources span across the entire Kubernetes cluster.</p>"},{"location":"tests/what-is-a-test/#purpose-of-the-namespacer-interface","title":"Purpose of the Namespacer Interface","text":"<p>The Namespacer interface ensures automated and consistent namespace assignment to Kubernetes resources.</p> <ul> <li>Automated Namespacing: Automatically assign namespaces to resources that don't have one.</li> <li>Ephemeral Namespaces: Handles temporary namespaces for specific tasks.</li> </ul>"},{"location":"tests/with-manifests/","title":"Manifests based syntax","text":"<p>This is the simplest and less verbose supported syntax, you provide bare Kubernetes resource manifests and Chainsaw will use those manifests to create, update, or assert expectations against a cluster.</p> <p>While this syntax is simple, it doesn't support deletion operations and doesn't allow specifying additional configuration per test or step.</p> <p>It also relies a lot on file naming conventions and makes it hard to reuse files across multiple tests.</p>"},{"location":"tests/with-manifests/#file-naming-convention","title":"File naming convention","text":"<p>Manifest files must follow the naming convention <code>&lt;step index&gt;-&lt;name|assert|error&gt;.yaml</code>.</p> <p>As an example <code>00-configmap.yaml</code>, <code>01-assert.yaml</code> and <code>02-error.yaml</code> can all be considered valid file names.</p> <p>It's also perfectly valid to have multiple files for the same step. Let's imagine we have the following files <code>00-resources.yaml</code>, <code>00-more-resources.yaml</code>, <code>00-assert.yaml</code> and <code>00-error.yaml</code>:</p> <ul> <li><code>00-resources.yaml</code> and <code>00-more-resources.yaml</code> contain resources that will be applied in step <code>00</code></li> <li><code>00-assert.yaml</code> contains assert statements in step <code>00</code></li> <li><code>00-error.yaml</code> contains error statements in step <code>00</code></li> </ul> <p>With the four files above, Chainsaw will assemble a test step made of the combination of all those files.</p>"},{"location":"tests/with-manifests/#manifests-loading-process","title":"Manifests loading process","text":"<p>The logic to determine the content of a step is always:</p> <ul> <li>The step index is obtained from the beginning of the file name, it must be composed of two numbers between <code>0</code> and <code>9</code> (from <code>00</code> to <code>99</code>)</li> <li>The next character acts as a separator and is expected to be <code>-</code></li> <li>The rest of the file name (without extension) is then evaluated<ul> <li>If it is equal to <code>assert</code>, the content is considered assertion statements</li> <li>If it is equal to <code>error</code>, the content is considered error statements</li> <li>Else the content is considered resources to be applied</li> </ul> </li> <li>The extension must be <code>.yaml</code> or <code>.yml</code></li> </ul>"},{"location":"tests/with-manifests/#example","title":"Example","text":""},{"location":"tests/with-manifests/#01-configmapyaml","title":"01-configmap.yaml","text":"<p>The manifest below contains a config map in a file called <code>01-configmap.yaml</code>. Chainsaw will associate this manifest with an apply operation in step <code>01</code>.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\n</code></pre>"},{"location":"tests/with-manifests/#02-assertyaml","title":"02-assert.yaml","text":"<p>The manifest below contains an assertion statement in a file called <code>02-assert.yaml</code>. Chainsaw will associate this manifest with an assert operation in step <code>02</code>.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\n</code></pre>"},{"location":"tests/with-manifests/#03-erroryaml","title":"03-error.yaml","text":"<p>The manifest below contains an error statement in a file called <code>03-error.yaml</code>. Chainsaw will associate this manifest with an error operation in step <code>03</code>.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  lorem: ipsum\n</code></pre>"},{"location":"tests/with-manifests/#conclusion","title":"Conclusion","text":"<p>This test will first create a config map, then assert the content of the config map contains the <code>foo: bar</code> data, and then verify that the configmap does not contain the <code>lorem: ipsum</code> data.</p> <p>Assert and error statements are very similar to standard resource definitions, they share the same structure but can be partial. Chainsaw will process only the elements present in the statements against the actual resource definition.</p>"},{"location":"tests/with-test-steps/","title":"<code>TestStep</code>s based syntax","text":"<p>The <code>TestStep</code>s based syntax is more verbose than the manifests based one but offers more flexibility to influence how a test step runs.</p> <p>It allows providing additional configuration per specific step, and makes it easier to reuse files accross multiple tests.</p> <p>This document focuses on understanding how <code>TestStep</code>s work.</p> <p>Keep in mind that a <code>TestStep</code>, like with the manifest based syntax, relies on file naming conventions. On the other hand it doesn't suffer the unsupported deletion limitation and can be combined with manifests based syntax when defining a step.</p>"},{"location":"tests/with-test-steps/#the-teststep-resource","title":"The <code>TestStep</code> resource","text":"<p>A <code>TestStep</code> resource, like any Kubernetes resource has an <code>apiVersion</code>, <code>kind</code> and <code>metadata</code> section.</p> <p>It also comes with a <code>spec</code> section used to declaratively represent the step operations and other configuration elements belonging to the step being defined.</p> <p>The full structure of the <code>TestStep</code> resource is documented here.</p>"},{"location":"tests/with-test-steps/#teststep-loading-process","title":"<code>TestStep</code> loading process","text":"<p>In addition to the manifests loading process, if the manifest being loading is a <code>TestStep</code> it is directly aggregated in the steps that compose the test (it would not make sense to consider the <code>TestStep</code> a resource to be applied in the target cluster).</p> <p>Manifests that are not a <code>TestStep</code> are processed as usual and participate to the test step being loaded in the same way they do with manifests based syntax.</p> <p>Note that it's only allowed to have a single <code>TestStep</code> resource for a given test step.</p>"},{"location":"tests/with-test-steps/#raw-resource-support","title":"Raw Resource Support","text":"<p>Chainsaw now allows the specification of Kubernetes resources directly within the TestStep definition. This raw resource feature enhances flexibility by allowing inline resource definitions, particularly useful for concise or reusable configurations.</p>"},{"location":"tests/with-test-steps/#example","title":"Example","text":""},{"location":"tests/with-test-steps/#01-test-stepyaml","title":"01-test-step.yaml","text":"<p>The manifest below contains a <code>TestStep</code> in a file called <code>01-test-step.yaml</code>. Chainsaw will load the <code>TestStep</code> in step <code>01</code>. The <code>TestStep</code> defines a custom <code>timeout</code> for step <code>01</code> and references a config map manifest from a relative path.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: test-step-name\nspec:\n  skipDelete: true\n  # these timeouts are applied per operation\n  # it would not be possible to override the timeouts\n  # with a manifests based approach\n  timeouts:\n    apply: 45s\n  try:\n  # apply a configmap to the cluster\n  # the path to the configmap is relative to the folder\n  # containing the test, hence allow reusing manifests\n  # across multiple tests\n  - apply:\n      file: ../resources/configmap.yaml\n</code></pre>"},{"location":"tests/with-test-steps/#02-assertyaml","title":"02-assert.yaml","text":"<p>The manifest below contains an assertion statement in a file called <code>02-assert.yaml</code>. Chainsaw will associate this manifest with an assert operation in step <code>02</code>. Note that this file doesn't contain a <code>TestStep</code> resource.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\n</code></pre>"},{"location":"tests/with-test-steps/#02-erroryaml","title":"02-error.yaml","text":"<p>The manifest below contains a <code>TestStep</code> in a file called <code>02-error.yaml</code>. Chainsaw will load the <code>TestStep</code> and aggregate it in step <code>02</code>. The <code>TestStep</code> defines a custom <code>timeout</code> for step <code>02</code> and references an error statement manifest from a relative path.</p> <p>This illustrates how a <code>TestStep</code> resource can be combined with raw manifests to compose a test step in Chainsaw.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: test-step-name\nspec:\n  # these timeouts are applied per operation\n  # it would not be possible to override the timeouts\n  # with a manifests based approach\n  timeouts:\n    error: 20s\n  try:\n  # evaluate an error statement against resources\n  # present in the cluster\n  - error:\n      file: ../resources/configmap-error.yaml\n</code></pre>"},{"location":"tests/with-test-steps/#02-assert-execyaml","title":"02-assert-exec.yaml","text":"<p>This manifest contains both an assertion and an exec operation, showing how you can mix operations in a single step.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: test-step-name-02\nspec:\n  try:\n  - assert:\n      file: ../resources/configmap-assert.yaml\n  - command:\n      entrypoint: \"echo\"\n      args:\n      - \"Hello Chainsaw\"\n</code></pre>"},{"location":"tests/with-test-steps/#example-raw-resource","title":"Example Raw Resource","text":""},{"location":"tests/with-test-steps/#01-test-stepyaml_1","title":"01-test-step.yaml","text":"<p>This <code>TestStep</code> defines a custom <code>timeout</code> and applies a <code>ConfigMap</code> directly within the step using the <code>raw resource</code> feature.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: test-step-name\nspec:\n  skipDelete: true\n  timeouts:\n    apply: 45s\n  try:\n  - apply:\n      resource:\n        apiVersion: v1\n        kind: ConfigMap\n        metadata:\n          name: chainsaw-quick-start\n        data:\n          foo: bar\n</code></pre>"},{"location":"tests/with-test-steps/#02-assertyaml_1","title":"02-assert.yaml","text":"<p>This manifest contains an assertion statement for a <code>ConfigMap</code> and does not include a <code>TestStep</code> resource.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: chainsaw-quick-start\ndata:\n  foo: bar\n</code></pre>"},{"location":"tests/with-test-steps/#02-erroryaml_1","title":"02-error.yaml","text":"<p>The manifest below contains a <code>TestStep</code> in a file called <code>02-error.yaml</code>. Chainsaw will load the <code>TestStep</code> and aggregate it in step <code>02</code>.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: test-step-name\nspec:\n  timeouts:\n    error: 20s\n  try:\n  - error:\n      file: ../resources/configmap-error.yaml\n</code></pre>"},{"location":"tests/with-test-steps/#conclusion","title":"Conclusion","text":"<p>This test will create a config map in the first step. The second step will both assert that the content of the config map contains the <code>foo: bar</code> data, and verify that the configmap does not contain the <code>lorem: ipsum</code> data.</p> <p>The first step is made of a single <code>TestStep</code> resource, while the second step is the combination of a <code>TestStep</code> resource and a raw manifest.</p>"},{"location":"tests/with-test/","title":"<code>Test</code>s based syntax","text":"<p>The <code>Test</code> based approach is the more verbose and explicit syntax.</p> <p>It does not rely on file naming conventions, it makes it easy to reuse files accross multiple tests, it offers the flexibility to provide additional configuration at both the test and test step level and supports all operations.</p>"},{"location":"tests/with-test/#the-test-resource","title":"The <code>Test</code> resource","text":"<p>A <code>Test</code> resource, like any Kubernetes resource has an <code>apiVersion</code>, <code>kind</code> and <code>metadata</code> section.</p> <p>It also comes with a <code>spec</code> section used to declaratively represent the steps of a test and other configuration elements belonging to the test being defined.</p> <p>The full structure of the <code>Test</code> resource is documented here.</p>"},{"location":"tests/with-test/#test-loading-process","title":"<code>Test</code> loading process","text":"<p>A <code>Test</code> resource is self-contained and fully represents a test. Chainsaw loads the Test and adds it to the collection of tests to be processed. By default, Chainsaw expects the file name to match <code>chainsaw-test.yaml</code>. However, this can be customized using the <code>--test-file</code> command flag.</p>"},{"location":"tests/with-test/#example","title":"Example","text":""},{"location":"tests/with-test/#chainsaw-testyaml","title":"chainsaw-test.yaml","text":"<p>The manifest below contains a <code>Test</code> in a file called <code>chainsaw-test.yaml</code>. Chainsaw will load the <code>Test</code> and steps defined in its <code>spec</code> section. The <code>Test</code> defines a custom <code>timeout</code> for the whole test. Note that the <code>timeout</code> could have been overridden in specific steps if needed.</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: test-name\nspec:\n  skip: false\n  concurrent: false\n  skipDelete: false\n  # these timeouts are applied per operation\n  timeouts:\n    apply: 10s\n    assert: 10s\n    error: 10s\n  steps:\n  # first step\n  # apply a configmap to the cluster\n  # the path to the configmap is relative to the folder\n  # containing the test, hence allow reusing manifests\n  # across multiple tests\n  - try:\n    - apply:\n        file: ../resources/configmap.yaml\n  # second step\n  # execute assert statements against existing resources\n  # in the cluster\n  - try:\n    - assert:\n        file: ../resources/configmap-assert.yaml\n  # third step\n  # execute error statements against existing resources\n  # in the cluster\n  - try:\n    - error:\n        file: ../resources/configmap-error.yaml\n</code></pre>"},{"location":"tests/with-test/#specifying-a-custom-test-file","title":"Specifying a Custom Test File","text":"<p>If you have your test defined in a different file, you can specify it when running Chainsaw:</p> <pre><code>chainsaw test --test-dir . --test-file=&lt;custom-test-file-name&gt;.yaml\n</code></pre>"},{"location":"tests/with-test/#raw-resource-support","title":"Raw Resource Support","text":"<p>Chainsaw now includes the raw resource feature, allowing direct specification of Kubernetes resources within the test definitions. This feature offers a more streamlined approach for defining resources, especially useful for simpler test scenarios or for cases where resource definitions need to be reused or slightly modified across different tests.</p>"},{"location":"tests/with-test/#example-raw-resource","title":"Example Raw Resource","text":"<pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: test-name\nspec:\n  skip: false\n  concurrent: false\n  skipDelete: false\n  timeouts:\n    apply: 10s\n    assert: 10s\n    error: 10s\n  steps:\n  # first step applies a configmap directly to the cluster\n  - try:\n    - apply:\n        resource:\n          apiVersion: v1\n          kind: ConfigMap\n          metadata:\n            name: chainsaw-quick-start\n          data:\n            foo: bar\n  # second step executes assert statements against existing resources\n  - try:\n    - assert:\n        file: ../resources/configmap-assert.yaml\n  # third step executes error statements against existing resources\n  - try:\n    - error:\n        file: ../resources/configmap-error.yaml\n</code></pre>"},{"location":"tests/catch-finally/","title":"What is catch / finally","text":"<p>Catch and Finally are additional fields to collect certain information about the outcome of a step should it fail (in the case of <code>catch</code>) or at the end of the step (in the case of <code>finally</code>). The ultimate goal of collectors is to gather information about the failure of a step and therefore help understand what caused it to fail.</p> <p>A test step can have an arbitrary number of collectors.</p> <p>Note</p> <p><code>catch</code> operations are only invoked in cases where a failure occurs and not if the step succeeds.</p> <p><code>finally</code> operations are always invoked regardles of the test success or failure.</p> <p>Collection can occur from:</p> <ul> <li>Pod logs</li> <li>Namespace events</li> <li>Or the output of a custom command or script</li> </ul>"},{"location":"tests/catch-finally/#catch-lifecycle","title":"Catch lifecycle","text":"<p>The <code>catch</code> operations are executed after the step failed, and before the step cleanup happens.</p> <p>Catch lifecycle</p> <ol> <li>The step starts executing</li> <li>An operation fails (before catch operations are executed)</li> <li>Catch operations are executed</li> <li>The step cleanup executes (after catch operations are executed)</li> </ol> <p>This is important that collectors run before cleanup so that they have a chance to collect logs from pods responsible for the step failure.</p>"},{"location":"tests/catch-finally/#configuration","title":"Configuration","text":"<p>Catch / Finally are a per step configuration and are registered under the <code>catch</code> / <code>finally</code> sections of a test step spec.</p> <p>Collect pod logs</p> <p><pre><code>    try:\n    # ...\n    catch:\n    - podLogs:\n        name: my-pod\n    finally:\n    - podLogs:\n        name: my-pod\n</code></pre> See Pod logs for details and supported configurations.</p> <p>Collect events</p> <p><pre><code>    try:\n    # ...\n    catch:\n    - events: {}\n    finally:\n    - events: {}\n</code></pre> See Events for details and supported configurations.</p> <p>Execute a custom command</p> <p><pre><code>    try:\n    # ...\n    catch:\n    - command:\n        entrypoint: kubectl\n        args:\n        - get\n        - pod\n        - -n\n        - $NAMESPACE\n    finally:\n    - command:\n        entrypoint: kubectl\n        args:\n        - get\n        - pod\n        - -n\n        - $NAMESPACE\n</code></pre> See Commands for details and supported configurations.</p> <p>Execute a custom script</p> <p><pre><code>    try:\n    # ...\n    catch:\n    - script:\n        content: |\n          echo \"an error has occured\"\n    finally:\n    - script:\n        content: |\n          echo \"goodbye\"\n</code></pre> See Scripts for details and supported configurations.</p>"},{"location":"tests/catch-finally/commands/","title":"Commands","text":"<p>In addition to collecting pod logs and events, Chainsaw also supports arbitrary commands as collectors.</p>"},{"location":"tests/catch-finally/commands/#configuration","title":"Configuration","text":"<p>The full structure of the <code>Command</code> resource is documented here.</p>"},{"location":"tests/catch-finally/commands/#simple-command","title":"Simple command","text":"<p>A <code>Command</code> must have at least the <code>entrypoint</code> defined.</p> <p>Simple command</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - command:\n        entrypoint: time\n</code></pre>"},{"location":"tests/catch-finally/commands/#command-with-arguments","title":"Command with arguments","text":"<p><code>Command</code> arguments can be provided using the <code>args</code> field.</p> <p>Command arguments</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - command:\n        entrypoint: kubectl\n        args:\n        - get\n        - pod\n        - -n\n        - $NAMESPACE\n</code></pre>"},{"location":"tests/catch-finally/commands/#timeout","title":"Timeout","text":"<p>An optional <code>timeout</code> can be configured.</p> <p>Note</p> <p>Note that the <code>timeout</code> lives at the operation level, not at the <code>script</code> level.</p> <p>Timeout example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - command:\n        entrypoint: kubectl\n        args:\n        - get\n        - pod\n        - -n\n        - $NAMESPACE\n      timeout: 30s\n</code></pre>"},{"location":"tests/catch-finally/events/","title":"Events","text":"<p>Collecting namespace events can help understand what happened inside the cluster.</p>"},{"location":"tests/catch-finally/events/#configuration","title":"Configuration","text":"<p>The full structure of the <code>Events</code> resource is documented here.</p>"},{"location":"tests/catch-finally/events/#single-event","title":"Single event","text":"<p>If a <code>name</code> is specified, Chainsaw will retrieve the specified event in the test namespace.</p> <p>Collect event in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events:\n        name: my-event\n</code></pre> <p>If a <code>namespace</code> is specified, Chainsaw will retrieve the specified event in the specified namespace.</p> <p>Collect event in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events:\n        name: my-event\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/events/#all-events","title":"All events","text":"<p>If no <code>name</code> and <code>namespace</code> is specified, Chainsaw will retrieve all events in the test namespace.</p> <p>Collect all events in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events: {}\n</code></pre> <p>On the other hand, if a <code>namespace</code> is specified, Chainsaw will retrieve all events in the specified namespace.</p> <p>Collect all events in a specific namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events:\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/events/#label-selector","title":"Label selector","text":"<p>An optional label selector can be configured to refine the events to be retrieved.</p> <p>Collect events using a label selector in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events:\n        selector: app=my-app\n</code></pre> <p>If a <code>namespace</code> is specified, Chainsaw will retrieve events using the specified namespace.</p> <p>Collect events using a label selector in a specific namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - events:\n        selector: app=my-app\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/pod-logs/","title":"Pod logs","text":"<p>Collecting pod logs can help understand what happened inside one or more pods.</p>"},{"location":"tests/catch-finally/pod-logs/#configuration","title":"Configuration","text":"<p>The full structure of the <code>PodLogs</code> resource is documented here.</p>"},{"location":"tests/catch-finally/pod-logs/#single-pod","title":"Single pod","text":"<p>If a pod <code>name</code> is specified, Chainsaw will retrieve logs from this specific pod in the test namespace.</p> <p>Collect pod logs in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        name: my-pod\n</code></pre> <p>If a <code>namespace</code> is specified, Chainsaw will retrieve logs from this specific pod in the specified namespace.</p> <p>Collect pod logs in a specific namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        name: my-pod\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/pod-logs/#all-pods","title":"All pods","text":"<p>If no pod <code>name</code> and <code>namespace</code> is specified, Chainsaw will retrieve logs from all pods in the test namespace.</p> <p>Collect all pod logs in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs: {}\n</code></pre> <p>On the other hand, if a <code>namespace</code> is specified, Chainsaw will retrieve logs from all pods in the specified namespace.</p> <p>Collect all pod logs in a specific namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/pod-logs/#label-selector","title":"Label selector","text":"<p>An optional label selector can be configured to refine the pods to retrieve logs from.</p> <p>Collect pod logs using a label selector in the test namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        selector: app=my-app\n</code></pre> <p>If a <code>namespace</code> is specified, Chainsaw will retrieve pod logs using the specified namespace.</p> <p>Collect pod logs using a label selector in a specific namespace</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        selector: app=my-app\n        namespace: foo\n</code></pre>"},{"location":"tests/catch-finally/pod-logs/#tail","title":"Tail","text":"<p>The <code>tail</code> field can be used to limit the amount of log lines retrieved when querying pod logs.</p> <p>Note</p> <p>By default, <code>tail</code> will be <code>10</code> when a label selector is used, and <code>all</code> if a pod <code>name</code> is specified.</p> <p>Tail example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        selector: app=my-app\n        namespace: foo\n        tail: 30\n</code></pre>"},{"location":"tests/catch-finally/pod-logs/#container","title":"Container","text":"<p>The <code>container</code> field can be used to retrieve logs from a specific container in the pod.</p> <p>Note</p> <p>By default logs from all containers will be fetched.</p> <p>Container example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - podLogs:\n        selector: app=my-app\n        namespace: foo\n        container: nginx\n</code></pre>"},{"location":"tests/catch-finally/scripts/","title":"Scripts","text":"<p>In addition to collecting pod logs and events, Chainsaw also supports arbitrary scripts as collectors.</p> <p>Shell</p> <p>Scripts require a shell to run, Chainsaw executes scripts with <code>sh -c ...</code>.</p> <p>If no shell is available, <code>Scripts</code> can't be used.</p>"},{"location":"tests/catch-finally/scripts/#configuration","title":"Configuration","text":"<p>The full structure of the <code>Script</code> resource is documented here.</p> <p>A <code>Script</code> must have a <code>content</code> defined.</p> <p>Simple command</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - script:\n        content: |\n          echo \"an error has occured\"\n</code></pre>"},{"location":"tests/catch-finally/scripts/#timeout","title":"Timeout","text":"<p>An optional <code>timeout</code> can be configured.</p> <p>Note</p> <p>Note that the <code>timeout</code> lives at the operation level, not at the <code>script</code> level.</p> <p>Timeout example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    - apply:\n        file: my-pod.yaml\n    - assert:\n        file: my-pod-assert.yaml\n    catch:\n    - script:\n        content: |\n          echo \"an error has occured\"\n      timeout: 30s\n</code></pre>"},{"location":"tests/operations/","title":"Operations","text":"<p>While tests are made of test steps, test steps can be considered made of operations.</p> <p>Every operation in a test steps runs sequentially.</p> <p>Only one action per operation</p> <p>Every operation consists of a single action. While it is syntactically possible to create an operation with multiple actions, Chainsaw will verify and reject tests if operations containing multiple actions are found.</p> <p>The reasoning behind this intentional choice is that it becomes harder to understand in which order actions will be executed in case an operation consists of multiple actions. For this reason operations consisting of multiple actions are disallowed.</p>"},{"location":"tests/operations/#common-fields","title":"Common fields","text":"<p>All operations share some configuration fields.</p> <ul> <li>Timeout: A timeout for the operation.</li> <li>ContinueOnError: Determines whether a test step should continue or not in case the operation was not successful.   Even if the test continues executing, it will still be reported as failed.</li> </ul> <p>Reference documentation</p> <p>The full structure of the <code>Operation</code> is documented here.</p>"},{"location":"tests/operations/#available-operations","title":"Available operations","text":"<ul> <li>Delete</li> <li>Apply</li> <li>Create</li> <li>Assert</li> <li>Error</li> <li>Command</li> <li>Script</li> </ul>"},{"location":"tests/operations/#operation-checks","title":"Operation checks","text":"<p>Some operations support checking the operation execution result against specific expectations.</p> <p>See Operation checks for use case details and supported operations.</p>"},{"location":"tests/operations/apply/","title":"Apply","text":"<p>The <code>apply</code> operation lets you define resources that should be applied to the Kubernetes cluster during the test step.</p> <p>These can be configurations, deployments, services, or any other Kubernetes resource.</p> <p>Reference documentation</p> <p>The full structure of the <code>Apply</code> is documented here.</p>"},{"location":"tests/operations/apply/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>apply</code> in a <code>Test</code> resource.</p> <p>Using a file</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - apply:\n        file: my-pod.yaml\n    # ...\n</code></pre> <p>Using an inline resource</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - apply:\n        resource:\n          apiVersion: v1\n          kind: ConfigMap\n          metadata:\n            name: chainsaw-quick-start\n          data:\n            foo: bar\n    # ...\n</code></pre>"},{"location":"tests/operations/apply/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>apply</code> in a <code>TestStep</code> resource.</p> <p>Using a file</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - apply:\n      file: my-pod.yaml\n  # ...\n</code></pre> <p>Using an inline resource</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - apply:\n      resource:\n        apiVersion: v1\n        kind: ConfigMap\n        metadata:\n          name: chainsaw-quick-start\n        data:\n          foo: bar\n  # ...\n</code></pre>"},{"location":"tests/operations/apply/#operation-check","title":"Operation check","text":"<p>Below is an example of using an operation check.</p> <p>With check</p> <pre><code># ...\n- apply:\n    file: my-pod.yaml\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre> <p>With check</p> <pre><code># ...\n- apply:\n    resource:\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: chainsaw-quick-start\n      data:\n        foo: bar\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre>"},{"location":"tests/operations/assert/","title":"Assert","text":"<p>The <code>assert</code> operation allows you to specify conditions that should hold true for a successful test. For example, after applying certain resources, you might want to ensure that a particular pod is running or a service is accessible.</p> <p>Info</p> <p>Assertions in Chainsaw are based on assertion trees.</p> <p>Assertion trees is a solution to declaratively represent complex conditions like partial array comparisons or complex operations against an incoming data structure.</p> <p>Assertion trees are compatible with standard assertions that exist in tools like KUTTL but can do a lot more. Please see the assertion trees documentation in kyverno-json for details.</p> <p>Reference documentation</p> <p>The full structure of the <code>Assert</code> is documented here.</p>"},{"location":"tests/operations/assert/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>assert</code> in a <code>Test</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - assert:\n        file: ../resources/configmap-assert.yaml\n    # ...\n</code></pre>"},{"location":"tests/operations/assert/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>assert</code> in a <code>TestStep</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - assert:\n      file: ../resources/configmap-assert.yaml\n  # ...\n</code></pre>"},{"location":"tests/operations/check/","title":"Operation checks","text":"<p>Considering an operation success or failure is not always as simple as checking an error code.</p> <ul> <li>Sometimes an operation can fail but the failure is what you expected, hence the operation should be reported as successful.</li> <li>Sometimes an operation can succeed but the result is not what you expected, in this case the operation should be reported as a failure.</li> </ul> <p>To support those kind of use cases, some operations support an additional <code>check</code> field to evaluate the operation result against an assertion tree.</p> <p>Checked model</p> <p>Different operation have a different model passed through the assertion tree.</p>"},{"location":"tests/operations/check/#apply","title":"Apply","text":"<p><code>apply</code> supports the following elements to be checked:</p> Name Purpose Type <code>error</code> The error message (if any) at the end of the operation <code>string</code> <code>resource</code> The state of the resource (if any) at the end of the operation <code>object</code>"},{"location":"tests/operations/check/#create","title":"Create","text":"<p><code>create</code> supports the following elements to be checked:</p> Name Purpose Type <code>error</code> The error message (if any) at the end of the operation <code>string</code> <code>resource</code> The state of the resource (if any) at the end of the operation <code>object</code>"},{"location":"tests/operations/check/#command","title":"Command","text":"<p><code>command</code> supports the following elements to be checked:</p> Name Purpose Type <code>error</code> The error message (if any) at the end of the operation <code>string</code> <code>stdout</code> The content of the standard console output (if any) at the end of the operation <code>string</code> <code>stderr</code> The content of the standard console error output (if any) at the end of the operation <code>string</code>"},{"location":"tests/operations/check/#script","title":"Script","text":"<p><code>script</code> supports the following elements to be checked:</p> Name Purpose Type <code>error</code> The error message (if any) at the end of the operation <code>string</code> <code>stdout</code> The content of the standard console output (if any) at the end of the operation <code>string</code> <code>stderr</code> The content of the standard console error output (if any) at the end of the operation <code>string</code>"},{"location":"tests/operations/command/","title":"Command","text":"<p>The <code>command</code> operation provides a means to execute a specific command during the test step.</p> <p>Reference documentation</p> <p>The full structure of the <code>Command</code> is documented here.</p>"},{"location":"tests/operations/command/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>command</code> in a <code>Test</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - command:\n        entrypoint: echo\n        args:\n        - hello chainsaw\n    # ...\n</code></pre>"},{"location":"tests/operations/command/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>command</code> in a <code>TestStep</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - command:\n      entrypoint: echo\n      args:\n      - hello chainsaw\n  # ...\n</code></pre>"},{"location":"tests/operations/command/#operation-check","title":"Operation check","text":"<p>Below is an example of using an operation check.</p> <p>With check</p> <pre><code># ...\n- command:\n    entrypoint: echo\n    args:\n    - hello chainsaw\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre>"},{"location":"tests/operations/create/","title":"Create","text":"<p>The <code>create</code> operation lets you define resources that should be created in the Kubernetes cluster during the test step. These can be configurations, deployments, services, or any other Kubernetes resource.</p> <p>Warning</p> <p>If the resource to be created already exists in the cluster, the step will fail.</p> <p>Reference documentation</p> <p>The full structure of the <code>Create</code> is documented here.</p>"},{"location":"tests/operations/create/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>create</code> in a <code>Test</code> resource.</p> <p>Using a file</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - create:\n        file: ../resources/configmap.yaml\n    # ...\n</code></pre> <p>Using an inline resource</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - create:\n        resource:\n          apiVersion: v1\n          kind: ConfigMap\n          metadata:\n            name: chainsaw-quick-start\n          data:\n            foo: bar\n    # ...\n</code></pre>"},{"location":"tests/operations/create/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>create</code> in a <code>TestStep</code> resource.</p> <p>Using a file</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - create:\n      file: ../resources/configmap.yaml\n  # ...\n</code></pre> <p>Using an inline resource</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - create:\n      resource:\n        apiVersion: v1\n        kind: ConfigMap\n        metadata:\n          name: chainsaw-quick-start\n        data:\n          foo: bar\n  # ...\n</code></pre>"},{"location":"tests/operations/create/#operation-check","title":"Operation check","text":"<p>Below is an example of using an operation check.</p> <p>With check</p> <pre><code># ...\n- apply:\n    file: my-pod.yaml\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre> <p>With check</p> <pre><code># ...\n- apply:\n    resource:\n      apiVersion: v1\n      kind: ConfigMap\n      metadata:\n        name: chainsaw-quick-start\n      data:\n        foo: bar\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre>"},{"location":"tests/operations/delete/","title":"Delete","text":"<p>The <code>delete</code> operation allows you to specify resources that should be deleted from the Kubernetes cluster before a particular test step is executed.</p> <p>Reference documentation</p> <p>The full structure of the <code>Delete</code> is documented here.</p>"},{"location":"tests/operations/delete/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>delete</code> in a <code>Test</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - delete:\n        apiVersion: v1\n        kind: Pod\n        namespace: default\n        name: my-test-pod\n    # ...\n</code></pre>"},{"location":"tests/operations/delete/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>delete</code> in a <code>TestStep</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - delete:\n      apiVersion: v1\n      kind: Pod\n      namespace: default\n      name: my-test-pod\n  # ...\n</code></pre>"},{"location":"tests/operations/error/","title":"Error","text":"<p>The <code>error</code> operation lets you define a set of expected errors for a test step. If any of these errors occur during the test, they are treated as expected outcomes. However, if an error that's not on this list occurs, it will be treated as a test failure.</p> <p>Info</p> <p>Errors in Chainsaw are based on assertion trees.</p> <p>Assertion trees is a solution to declaratively represent complex conditions like partial array comparisons or complex operations against an incoming data structure.</p> <p>Assertion trees are compatible with standard assertions that exist in tools like KUTTL but can do a lot more. Please see the assertion trees documentation in kyverno-json for details.</p> <p>Reference documentation</p> <p>The full structure of the <code>Error</code> is documented here.</p>"},{"location":"tests/operations/error/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>error</code> in a <code>Test</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - error:\n        file: ../resources/configmap-error.yaml\n    # ...\n</code></pre>"},{"location":"tests/operations/error/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>error</code> in a <code>TestStep</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - error:\n      file: ../resources/configmap-error.yaml\n  # ...\n</code></pre>"},{"location":"tests/operations/script/","title":"Script","text":"<p>The <code>script</code> operation provides a means to run a script during the test step.</p> <p>Reference documentation</p> <p>The full structure of the <code>Script</code> is documented here.</p>"},{"location":"tests/operations/script/#usage-in-test","title":"Usage in <code>Test</code>","text":"<p>Below is an example of using <code>script</code> in a <code>Test</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: Test\nmetadata:\n  name: example\nspec:\n  steps:\n  - try:\n    # ...\n    - script:\n        content: |\n          echo \"hello chainsaw\"\n    # ...\n</code></pre>"},{"location":"tests/operations/script/#usage-in-teststep","title":"Usage in <code>TestStep</code>","text":"<p>Below is an example of using <code>script</code> in a <code>TestStep</code> resource.</p> <p>Example</p> <pre><code>apiVersion: chainsaw.kyverno.io/v1alpha1\nkind: TestStep\nmetadata:\n  name: example\nspec:\n  try:\n  # ...\n  - script:\n      content: |\n        echo \"hello chainsaw\"\n  # ...\n</code></pre>"},{"location":"tests/operations/script/#operation-check","title":"Operation check","text":"<p>Below is an example of using an operation check.</p> <p>With check</p> <pre><code># ...\n- script:\n    content: |\n      echo \"hello chainsaw\"\n    check:\n      # an error is expected, this will:\n      # - succeed if the operation failed\n      # - fail if the operation succeeded\n      (error != null): true\n# ...\n</code></pre>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/writing-tests/","title":"Writing Tests","text":""},{"location":"blog/category/announcements/","title":"announcements","text":""}]}